#include <stdio.h>      // Biblioteca estándar para funciones de entrada y salida
#include <dirent.h>     // Biblioteca para manejar directorios
#include <ctype.h>      // Biblioteca para funciones relacionadas con caracteres
#include <stdlib.h>     // Biblioteca estándar de utilidades generales
#include <string.h>     // Biblioteca para manejar cadenas de caracteres
#include <sys/stat.h>   // Biblioteca para obtener información sobre archivos
#include <unistd.h>     // Biblioteca para acceder a constantes y tipos estándar

// Función para obtener el nombre del proceso desde el archivo cmdline
void get_process_cmd(char *filename, char *procname);

// Función para obtener la información del proceso desde el archivo stat
void get_process_stat(char *filename, char *statinfo);

// Función que verifica si una cadena es un número (para identificar PIDs)
int is_number(const char *s);

// Función que recorre el directorio /proc para listar procesos y sus archivos cmdline y stat
void explore_proc();

int main() {
    printf("Explorando el directorio /proc para listar procesos y sus cmdline y stat...\n\n");
    explore_proc();  // Llama a la función que explora el directorio /proc
    return 0;
}

// Esta función recorre el directorio /proc
void explore_proc() {
    struct dirent *entry;        // Estructura para manejar entradas de directorio
    DIR *pDir;                   // Puntero para el directorio
    char proc_dir[] = "/proc";    // Directorio de procesos
    char proc_id_dir[255];        // Para construir las rutas de los archivos de cada proceso
    char cmdline[255];            // Para almacenar el contenido del archivo cmdline
    char stat[1024];              // Para almacenar el contenido del archivo stat

    // Intenta abrir el directorio /proc
    pDir = opendir(proc_dir);
    if (pDir == NULL) {
        perror("No se pudo abrir el directorio /proc"); // Imprime error si no se puede abrir
        return;
    }

    // Recorre cada entrada en el directorio /proc
    while ((entry = readdir(pDir)) != NULL) {
        // Verifica si la entrada es un número (que corresponde a un PID de proceso)
        if (!is_number(entry->d_name)) {
            continue;  // Si no es un número, pasa a la siguiente entrada
        }

        // Construye la ruta del archivo cmdline para ese proceso
        sprintf(proc_id_dir, "/proc/%s/cmdline", entry->d_name);
        // Llama a la función para obtener el contenido del archivo cmdline
        get_process_cmd(proc_id_dir, cmdline);

        // Construye la ruta del archivo stat para ese proceso
        sprintf(proc_id_dir, "/proc/%s/stat", entry->d_name);
        // Llama a la función para obtener el contenido del archivo stat
        get_process_stat(proc_id_dir, stat);

        // Muestra el PID y la información cmdline y stat del proceso
        printf("PID: %s | CMDLINE: %s\n", entry->d_name, cmdline);
        printf("PID: %s | STAT: %s\n", entry->d_name, stat);
        printf("----------------------------------------\n");
    }

    // Cierra el directorio /proc después de recorrerlo
    closedir(pDir);
}

// Función que abre y lee el archivo cmdline de un proceso
void get_process_cmd(char *filename, char *procname) {
    FILE *fp;
    procname[0] = '\0'; // Inicializa la cadena vacía

    // Intenta abrir el archivo en modo solo lectura
    fp = fopen(filename, "r");

    // Si el archivo no se pudo abrir, imprime un mensaje y sale de la función
    if (fp == NULL) {
        printf("No se pudo abrir el archivo cmdline para el PID: %s\n", filename);
        return;
    }

    // Lee el contenido del archivo cmdline
    if (fgets(procname, 255, fp) != NULL) {
        // Reemplaza los caracteres nulos ('\0') por espacios para mejorar la legibilidad
        for (int i = 0; i < strlen(procname); i++) {
            if (procname[i] == '\0') {
                procname[i] = ' ';
            }
        }
    }
    
    // Cierra el archivo
    fclose(fp);
}

// Función que abre y lee el archivo stat de un proceso
void get_process_stat(char *filename, char *statinfo) {
    FILE *fp;
    statinfo[0] = '\0'; // Inicializa la cadena vacía

    // Intenta abrir el archivo en modo solo lectura
    fp = fopen(filename, "r");

    // Si el archivo no se pudo abrir, imprime un mensaje y sale de la función
    if (fp == NULL) {
        printf("No se pudo abrir el archivo stat para el PID: %s\n", filename);
        return;
    }

    // Lee el contenido del archivo stat en una sola línea
    if (fgets(statinfo, 1024, fp) != NULL) {
        // El contenido del archivo se almacena en 'statinfo'
    }

    // Cierra el archivo
    fclose(fp);
}

// Función que verifica si una cadena representa un número (para identificar procesos)
int is_number(const char *s) {
    while (*s) {
        // Verifica si cada carácter de la cadena es un dígito
        if (!isdigit(*s)) {
            return 0; // Si encuentra un carácter que no es un número, retorna 0 (falso)
        }
        s++;
    }
    return 1; // Si toda la cadena es numérica, retorna 1 (verdadero)
}
